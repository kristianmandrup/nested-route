// Generated by LiveScript 1.2.0
(function(){
  var nested, NestedRoute;
  nested = require('../../index');
  NestedRoute = nested.route.builder.NestedRoute;
  describe('NestedRoute', function(){
    var baseRoute, childRoute;
    beforeEach(function(){
      var baseRoute, childRoute;
      crossroads.removeAllRoutes();
      crossroads.resetState();
      baseRoute = crossroads.addRoute('/base/{foo}');
      childRoute = baseRoute.addRoute('child/{bar}');
      return baseRoute.addRoute('/another/child');
    });
    afterEach(function(){
      crossroads.removeAllRoutes();
      return crossroads.resetState();
    });
    describe('parse child', function(){
      specify('should match the child route', function(){
        var childMatched;
        childMatched = jasmine.createSpy();
        childRoute.matched.add(childMatched);
        crossroads.parse('/base/foo/child/bar');
        return expect(childMatched).toHaveBeenCalledWith('bar');
      });
      specify('should not match unkown children', function(){
        var bypassed;
        bypassed = jasmine.createSpy();
        crossroads.bypassed.add(bypassed);
        crossroads.parse('/base/foo/unkown');
        return expect(bypassed).toHaveBeenCalled();
      });
      specify('should match the ancestor route', function(){
        var ancestorMatched;
        ancestorMatched = jasmine.createSpy();
        baseRoute.matched.add(ancestorMatched);
        crossroads.parse('/base/foo/child/bar');
        return expect(ancestorMatched).toHaveBeenCalledWith('foo');
      });
      specify('should switch the child route', function(){
        var childSwitched;
        childSwitched = jasmine.createSpy();
        childRoute.switched.add(childSwitched);
        crossroads.parse('/base/foo/child/bar');
        crossroads.parse('/base/foo/another/child');
        return expect(childSwitched).toHaveBeenCalled();
      });
      specify('should not switch the ancestor route', function(){
        var ancestorSwitched;
        ancestorSwitched = jasmine.createSpy();
        baseRoute.switched.add(ancestorSwitched);
        crossroads.parse('/base/foo/child/bar');
        crossroads.parse('/base/foo/another/child');
        return expect(ancestorSwitched.calls.length).toEqual(0);
      });
      return specify('should match the index route', function(){
        var indexMatched, indexRoute;
        indexMatched = jasmine.createSpy();
        indexRoute = baseRoute.addRoute(indexMatched);
        crossroads.parse('/base/foo');
        return expect(indexMatched).toHaveBeenCalled();
      });
    });
    describe('parse multiple children', function(){
      var anotherChild;
      beforeEach(function(){
        var anotherChild;
        crossroads.greedy = true;
        return anotherChild = baseRoute.addRoute('/{child}/bar');
      });
      afterEach(function(){
        return crossroads.greedy = false;
      });
      specify('should match both children', function(){
        var childMatched;
        childMatched = jasmine.createSpy();
        childRoute.matched.add(childMatched);
        anotherChild.matched.add(childMatched);
        crossroads.parse('/base/foo/child/bar');
        return expect(childMatched.calls.length).toEqual(2);
      });
      return specify('should match ancestors only once', function(){
        var parentMatched;
        parentMatched = jasmine.createSpy();
        baseRoute.matched.add(parentMatched);
        crossroads.parse('/base/foo/child/bar');
        return expect(parentMatched.calls.length).toEqual(1);
      });
    });
    return describe('parse different bases', function(){
      beforeEach(function(){
        return crossroads.addRoute('/another');
      });
      specify('should switch the child route', function(){
        var childSwitched;
        childSwitched = jasmine.createSpy();
        childRoute.switched.add(childSwitched);
        crossroads.parse('/base/foo/child/bar');
        crossroads.parse('/another');
        return expect(childSwitched).toHaveBeenCalled();
      });
      specify('should switch the ancestor route', function(){
        var ancestorSwitched;
        ancestorSwitched = jasmine.createSpy();
        baseRoute.switched.add(ancestorSwitched);
        crossroads.parse('/base/foo/child/bar');
        crossroads.parse('/another');
        return expect(ancestorSwitched).toHaveBeenCalled();
      });
      return specify('should match only parent', function(){
        var childMatched, parentMatched;
        childMatched = jasmine.createSpy();
        parentMatched = jasmine.createSpy();
        childRoute.matched.add(childMatched);
        baseRoute.matched.add(parentMatched);
        crossroads.parse('/base/foo');
        expect(childMatched.calls.length).toEqual(0);
        return expect(parentMatched).toHaveBeenCalled();
      });
    });
  });
}).call(this);
